├── .git
├── README.md
├── backend
│   ├── .gitignore
│   ├── node_modules
│   ├── package-lock.json
│   ├── package.json
│   └── src
│       ├── .env
│       ├── config
│       │   ├── db.js
│       │   └── socket.js
│       ├── controllers
│       │   ├── chatController.js
│       │   ├── roomController.js
│       │   └── userController.js
│       ├── io.js
│       ├── middleware
│       │   ├── auth.js
│       │   ├── errorHandler.js
│       │   └── rateLimit.js
│       ├── models
│       │   ├── Message.js
│       │   ├── Room.js
│       │   └── User.js
│       ├── node.js
│       ├── routes
│       │   ├── chatRoutes.js
│       │   ├── roomRoutes.js
│       │   └── userRoutes.js
│       ├── server.js
│       └── tests
│           ├── integration
│           │   ├── chat.test.js
│           │   └── user.test.js
│           └── unit
│               ├── chat.test.js
│               └── user.test.js
├── frontend
│   ├── .gitignore
│   ├── README.md
│   ├── node_modules
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   ├── favicon.ico
│   │   ├── index.html
│   │   ├── logo192.png
│   │   ├── logo512.png
│   │   ├── manifest.json
│   │   └── robots.txt
│   └── src
│       ├── App.css
│       ├── App.js
│       ├── App.test.js
│       ├── components
│       │   ├── ChatRoom.js
│       │   ├── CreateRoom.js
│       │   ├── CreateRoomButton.js
│       │   ├── Home.js
│       │   ├── LoginForm.js
│       │   ├── LogoutButton.js
│       │   ├── PrivateChat.js
│       │   ├── ProtectedChatRoom.js
│       │   ├── ProtectedRoute.js
│       │   ├── RegisterForm.js
│       │   └── RoomList.js
│       ├── contexts
│       │   ├── AuthContext.js
│       │   └── ChatContext.js
│       ├── hooks
│       │   ├── UseAuth.js
│       │   └── UseChat.js
│       ├── index.css
│       ├── index.js
│       ├── logo.svg
│       ├── reportWebVitals.js
│       └── setupTests.js
├── source.txt
└── structure.py

==============================

-db.js
const IORedis = require('ioredis');

const client = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

client.on('connect', () => {
  console.log('Connected to Redis...');
});

client.on('error', (err) => {
  console.log('Redis error: ', err);
});

module.exports = client;


==============================

-socket.js
const socketIo = require("socket.io");
const chatController = require("../controllers/chatController");
const Redis = require("ioredis");
const { RateLimiterRedis } = require("rate-limiter-flexible");

const redisClient = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

const rateLimiter = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: "middleware",
  points: 10, // 10 requests
  duration: 60, // per 60 seconds by IP
});

// Maintain a mapping of user IDs to their socket IDs
const userSocketIds = {};

module.exports = (server, corsOptions) => {
  const io = socketIo(server, {
    cors: corsOptions,
  });

  io.on("connection", (socket) => {
    console.log("New client connected:", socket.id);

    socket.on("login", (userId) => {
      console.log(`User logged in with ID: ${userId}, Socket ID: ${socket.id}`);
      userSocketIds[userId] = socket.id;
      socket.join(userId);
    });

    socket.on("logout", (userId) => {
      console.log(`User logged out with ID: ${userId}`);
      delete userSocketIds[userId];
      socket.leave(userId);
    });

    socket.on("sendMessage", async (message) => {
      console.log("Received sendMessage event with message", message);

      rateLimiter
        .consume(socket.id)
        .then(async () => {
          const req = {
            body: message,
            user: { username: message.sender },
            io: io,
          };
          try {
            const result = await chatController.sendMessage(req);
            console.log(result);
          } catch (error) {
            console.error(error.message);
          }
        })
        .catch((rejRes) => {
          console.log(
            `Rate limit exceeded for ${socket.id}. Remaining points: ${rejRes.remainingPoints}`
          );
        });
    });

    socket.on("sendPrivateMessage", async (message) => {
      console.log("Received sendPrivateMessage event with message", message);

      rateLimiter
        .consume(socket.id)
        .then(async () => {
          const req = {
            body: message,
            user: { id: message.senderId },
            io: io,
            userSocketIds: userSocketIds, // Add this line
          };
          try {
            const result = await chatController.sendDirectMessage(req);
            console.log(result);

            // Emit the message to the receiver's room
            io.to(userSocketIds[message.receiverId]).emit(
              "privateMessage",
              result
            );
          } catch (error) {
            console.error(error.message);
          }
        })
        .catch((rejRes) => {
          console.log(
            `Rate limit exceeded for ${socket.id}. Remaining points: ${rejRes.remainingPoints}`
          );
        });
    });

    socket.on("disconnect", () => {
      console.log("Client disconnected:", socket.id);
    });
  });

  return io;
};


==============================

-chatController.js
const Message = require("../models/Message");
const Room = require("../models/Room");

exports.sendMessage = async (req) => {
  const { text, roomId } = req.body;
  const { username } = req.user;

  const members = await Room.client.smembers(`room:${roomId}:members`);

  if (!members.includes(username)) {
    throw new Error("You are not a member of this room");
  }

  try {
    const messageId = await Message.incr("message:id");
    const timestamp = Date.now();
    await Message.hset(
      `message:${messageId}`,
      "sender",
      username,
      "text",
      text,
      "timestamp",
      timestamp
    );
    await Message.lpush(`room:${roomId}:messages`, messageId);

    const message = { id: messageId, sender: username, text, timestamp };
    req.io.to(roomId).emit("receiveMessage", message);

    return { status: 200, message: "Message sent successfully" };
  } catch (error) {
    console.error("Send message error:", error);
    throw new Error("An error occurred while sending the message");
  }
};

exports.getMessages = async (req, res, next) => {
  console.log("getMessages controller called");

  const roomId = req.params.roomId;
  const { username } = req.user;

  console.log("roomId:", roomId);
  console.log("username:", username);

  const members = await Room.client.smembers(`room:${roomId}:members`);

  console.log("members:", members);

  if (!members.includes(username)) {
    return res.status(403).json({ error: "You are not a member of this room" });
  }

  try {
    const messageIds = await Message.lrange(`room:${roomId}:messages`, 0, -1);
    const messages = [];
    for (let messageId of messageIds) {
      const message = await Message.hgetall(`message:${messageId}`);
      message.id = messageId;
      messages.push(message);
    }

    console.log("messages:", messages);
    res.status(200).json({ messages });
  } catch (error) {
    console.error("Get messages error:", error);
    res.status(500).json({
      error: "An error occurred while getting the messages",
      details: error.message,
    });
  }
};

exports.sendDirectMessage = async (req) => {
  const { text, chatId } = req.body;
  const { username: senderUsername } = req.user;

  console.log(`senderUsername: ${senderUsername}`);
  console.log(`chatId: ${chatId}`);

  try {
    const messageId = await Message.incr("directMessage:id");
    const timestamp = Date.now();

    await Message.hset(
      `directMessage:${messageId}`,
      "sender",
      senderUsername,
      "chatId",
      chatId,
      "text",
      text,
      "timestamp",
      timestamp
    );
    await Message.lpush(`direct:${chatId}:messages`, messageId);

    const message = {
      id: messageId,
      sender: senderUsername,
      chatId,
      text,
      timestamp
    };

    req.io.to(chatId).emit("privateMessage", message);

    return { status: 200, message: "Message sent successfully" };
  } catch (error) {
    console.error("Send direct message error:", error);
    throw new Error("An error occurred while sending the message");
  }
};

exports.getPrivateMessages = async (req, res, next) => {
  const chatId = req.params.chatId;
  const { username: senderUsername } = req.user;

  try {
    const messageIds = await Message.lrange(`direct:${chatId}:messages`, 0, -1);

    const messages = [];
    for (let messageId of messageIds) {
      const message = await Message.hgetall(`directMessage:${messageId}`);
      message.id = messageId;
      messages.push(message);
    }

    console.log(`Fetched private messages: ${JSON.stringify(messages)}`);

    res.status(200).json({ messages });
  } catch (error) {
    console.error("Get private messages error:", error);
    res.status(500).json({
      error: "An error occurred while getting the messages",
      details: error.message,
    });
  }
};

exports.getConversation = async (req, res, next) => {
  const { id: senderId } = req.user;
  const { receiverId } = req.params;

  const [user1, user2] = [senderId, receiverId].sort();

  try {
    const messageIds = await Message.lrange(
      `direct:${user1}:${user2}:messages`,
      0,
      -1
    );

    const messages = [];
    for (let messageId of messageIds) {
      const message = await Message.hgetall(`directMessage:${messageId}`);
      message.id = messageId;
      messages.push(message);
    }

    console.log(`Fetched conversation: ${JSON.stringify(messages)}`);
    res.status(200).json({ messages });
  } catch (error) {
    console.error("Get conversation error:", error);
    res.status(500).json({
      error: "An error occurred while getting the conversation",
      details: error.message,
    });
  }
};


==============================

-roomController.js
// roomController.js
const Room = require('../models/Room');


exports.getRoomMembers = async (req, res, next) => {
  const { roomId } = req.params;

  try {
    const members = await Room.client.smembers(`room:${roomId}:members`);
    res.status(200).json({ members });
  } catch (error) {
    console.error('Get room members error:', error);
    next(error);
  }
};


exports.createRoom = async (req, res, next) => {
  const { name } = req.body;

  try {
    const roomId = await Room.createRoom(name);
    res.status(201).json({ message: 'Room created successfully', roomId });
  } catch (error) {
    console.error('Create room error:', error);
    next(error);
  }
};

exports.joinRoom = async (req, res, next) => {
  const { roomId } = req.params;
  const { username } = req.user;

  try {
    await Room.joinRoom(roomId, username);
    res.status(200).json({ message: 'Joined room successfully' });
  } catch (error) {
    console.error('Join room error:', error);
    next(error);
  }
};

exports.leaveRoom = async (req, res, next) => {
  const { roomId } = req.params;
  const { username } = req.user;

  try {
    await Room.leaveRoom(roomId, username);
    res.status(200).json({ message: 'Left room successfully' });
  } catch (error) {
    console.error('Leave room error:', error);
    next(error);
  }
};

exports.getRooms = async (req, res, next) => {
  try {
    const rooms = await Room.getRooms();
    res.status(200).json({ rooms });
  } catch (error) {
    console.error('Get rooms error:', error);
    next(error);
  }
};

exports.deleteRoom = async (req, res, next) => {
  const { roomId } = req.params;

  try {
    await Room.deleteRoom(roomId);
    res.status(200).json({ message: 'Room deleted successfully' });
  } catch (error) {
    console.error('Delete room error:', error);
    next(error);
  }
};

exports.editRoom = async (req, res, next) => {
  const { roomId } = req.params;
  const { newName } = req.body;

  try {
    await Room.editRoom(roomId, newName);
    res.status(200).json({ message: 'Room edited successfully' });
  } catch (error) {
    console.error('Edit room error:', error);
    next(error);
  }
};



==============================

-userController.js
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const User = require("../models/User");
const IORedis = require("ioredis");
let redis = User.client;

exports.register = async (req, res, next) => {
  const { username, password } = req.body;

  try {
    const userExists = await User.verifyUser(username);
    if (userExists) {
      return res.status(400).json({ error: "Username already taken" });
    }

    await User.addUser(username, password);

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Registration error:", error);
    next(error);
  }
};

exports.login = async (req, res, next) => {
  const { username, password } = req.body;

  try {
    const user = await User.getUser(username);

    if (!user || !user.password) {
      return res.status(400).json({ error: "User does not exist" });
    }

    const validPassword = await bcrypt.compare(password, user.password);

    if (!validPassword) {
      return res.status(400).json({ error: "Invalid password" });
    }

    if (!process.env.JWT_SECRET) {
      console.error("JWT_SECRET is not defined in the environment variables.");
      return res.status(500).json({ error: "Internal server error" });
    }

    const token = jwt.sign({ username }, process.env.JWT_SECRET, {
      expiresIn: "1h",
    });

    // Set the JWT token in an HTTP-only cookie
    res.cookie("token", token, {
      httpOnly: true,
      sameSite: "strict", // or 'lax' depending on your needs
      secure: false, // set this to true if your website runs on https, otherwise set it to false
      maxAge: 3600000, // token expiration time in milliseconds, this is equal to 1 hour
    });

    res.status(200).json({ message: "User logged in successfully", username });
  } catch (error) {
    console.error("Login error:", error);
    next(error);
  }
};

exports.logout = async (req, res, next) => {
  // Add the existing token to the invalidated tokens set
  const token = req.cookies.token;
  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    await redis.sadd("invalidatedTokens", token);

    // Clear the token cookie
    res.clearCookie("token");

    // Emit logout event
    io.emit('logout', req.user.username); // assuming req.user.username is available

    res.status(200).json({ message: "User logged out successfully" });
  } catch (error) {
    console.error("Logout error:", error);
    next(error);
  }
};



==============================

-io.js
// io.js
const socketIo = require('socket.io');

module.exports = function(server) {
  const io = socketIo(server);

  io.on('connection', (socket) => {
    console.log('New client connected');

    socket.on('joinRoom', (roomId) => {
      socket.join(roomId);
    });

    socket.on('leaveRoom', (roomId) => {
      socket.leave(roomId);
    });

    socket.on('sendMessage', (message) => {
      io.to(message.roomId).emit('receiveMessage', message);
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected');
    });
  });

  return io;
};

==============================

-auth.js
const jwt = require('jsonwebtoken');
const cookieParser = require('cookie-parser');
const IORedis = require('ioredis');

const client = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

exports.authenticate = async (req, res, next) => {
  console.log('authenticate middleware called');  // Log that the middleware has been called

  const token = req.cookies.token;

  if (!token) {
    console.log('No token provided');  // Log that no token was provided
    return res.status(401).json({ error: 'No token provided' });
  }

  // Check if the token is invalidated
  const isInvalidated = await client.sismember("invalidatedTokens", token);
  if (isInvalidated) {
    console.log('The token is invalidated');  // Log that the token was invalidated
    return res.status(401).json({ error: 'The token is invalidated' });
  }

  // Check if the JWT_SECRET is defined
  if (!process.env.JWT_SECRET) {
    console.log('Internal server error - JWT_SECRET not defined');  // Log that JWT_SECRET is not defined
    return res.status(500).json({ error: 'Internal server error' });
  }

  try {
    console.log('Before jwt.verify');  // Add this line
    const user = jwt.verify(token, process.env.JWT_SECRET);
    console.log('After jwt.verify');  // Add this line
    console.log('User:', user);  // Log the user object
    req.user = user;
    next();
} catch (error) {
    console.log('jwt.verify error:', error.message);
    return res.status(401).json({ error: 'Invalid token' });
}



};


==============================

-errorHandler.js
exports.errorHandler = (err, req, res, next) => {
    console.error(err);
    res.status(500).json({ error: err.message });
  };
  

==============================

-rateLimit.js
const socketio = require('socket.io');
const Redis = require('ioredis');
const { RateLimiterRedis } = require('rate-limiter-flexible');

const redisClient = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

const rateLimiter = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: 'middleware',
  points: 3, // 10 requests
  duration: 60, // per 60 seconds by IP
});

const io = socketio(server, corsOptions);

io.on('connection', (socket) => {
  console.log('New client connected');

  socket.on('chat message', (msg) => {
    rateLimiter.consume(socket.id) // use socket.id as unique user identifier
      .then(() => {
        io.emit('chat message', msg);
      })
      .catch((rejRes) => {
        console.log(`Rate limit exceeded for ${socket.id}. Remaining points: ${rejRes.remainingPoints}`);
        // Handle rate limit exceed. You might want to send a message to the user, close the connection, etc.
      });
  });

  socket.on('disconnect', () => {
    console.log('Client disconnected');
  });
});


==============================

-Message.js
const IORedis = require("ioredis");

const messageClient = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
  retryStrategy: function (times) {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
});

messageClient.on("error", (err) => {
  console.log("Error", err);
});

// Message data structure
// id (IORedis will generate this id)
// sender
// text
// timestamp

module.exports = messageClient;


==============================

-Room.js
// Room.js
const IORedis = require('ioredis');
const client = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
  retryStrategy: function(times) {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
});

client.on('connect', () => {
  console.log('Redis client connected');
});

client.on('error', (err) => {
  console.log('Error', err);
});

// Room data structure
// id (IORedis will generate this id)
// name
// members

async function createRoom(name) {
  const roomId = await client.incr('room:id');
  await client.hset(`room:${roomId}`, 'name', name);
  await client.sadd('rooms', roomId);
  return roomId;
}

async function joinRoom(roomId, username) {
  await client.sadd(`room:${roomId}:members`, username);
}

async function leaveRoom(roomId, username) {
  await client.srem(`room:${roomId}:members`, username);
}

async function getRooms() {
  const roomIds = await client.smembers('rooms');
  const rooms = [];
  for (let roomId of roomIds) {
    const room = await client.hgetall(`room:${roomId}`);
    room.members = await client.smembers(`room:${roomId}:members`);
    room.id = roomId; // Add this line
    rooms.push(room);
  }
  return rooms;
}

async function deleteRoom(roomId) {
  await client.del(`room:${roomId}`);
  await client.srem('rooms', roomId);
}

async function editRoom(roomId, newName) {
  await client.hset(`room:${roomId}`, 'name', newName);
}

module.exports = {
  createRoom,
  joinRoom,
  leaveRoom,
  getRooms,
  deleteRoom,
  editRoom,
  client,
};

==============================

-User.js
console.log("REDIS_HOST:", process.env.REDIS_HOST);
console.log("REDIS_PORT:", process.env.REDIS_PORT);
console.log("REDIS_PASSWORD:", process.env.REDIS_PASSWORD);

const IORedis = require("ioredis");
const bcrypt = require("bcrypt");

console.log("About to create Redis client");

// Create Redis client
const redisClient = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
  retryStrategy: function (times) {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
});

console.log("Redis client created");

redisClient.on("connect", () => {
  console.log("Redis client connected");
});

redisClient.on("error", (err) => {
  console.error("Redis error:", err);
});

console.log("Successfully connected to Redis");

// Redis functions
async function addUser(username, password) {
  const hashedPassword = await hashPassword(password);
  await redisClient.hset(`user:${username}`, "password", hashedPassword);
}

async function hashPassword(password) {
  const salt = await bcrypt.genSalt(10);
  return await bcrypt.hash(password, salt);
}

async function verifyUser(username) {
  const password = await redisClient.hget(`user:${username}`, 'password');
  return password !== null;
}

async function getUser(username) {
  return await redisClient.hgetall(`user:${username}`);
}

module.exports = {
  addUser,
  verifyUser,
  getUser,
  client: redisClient,
};


==============================

-node.js
require("dotenv").config();
const Redis = require("ioredis");

console.log("REDIS_HOST:", process.env.REDIS_HOST);
console.log("REDIS_PORT:", process.env.REDIS_PORT);
console.log("REDIS_PASSWORD:", process.env.REDIS_PASSWORD);

const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

redis.on("connect", () => {
  console.log("Redis client connected");
});

redis.on("error", (err) => {
  console.error("Redis error:", err);
});

// Keep the script running until manually stopped
setInterval(() => {}, 1000);


==============================

-chatRoutes.js
const express = require("express");
const router = express.Router();
const chatController = require("../controllers/chatController");
const { authenticate } = require("../middleware/auth");
const rateLimit = require("express-rate-limit");

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 3, // limit each IP to 3 requests per windowMs
  message:
    "Too many messages created from this IP, please try again after an hour",
});

router.post("/send", authenticate, apiLimiter, chatController.sendMessage);
router.post("/sendDirect", authenticate, apiLimiter, chatController.sendDirectMessage); // New route for direct messages
router.get("/messages/:roomId", authenticate, chatController.getMessages);
router.get("/privateMessages/:chatId", authenticate, chatController.getPrivateMessages); // Modified route
router.get('/conversation/:receiverId', authenticate, chatController.getConversation);

module.exports = router;


==============================

-roomRoutes.js
// roomRoutes.js
const express = require('express');
const router = express.Router();
const roomController = require('../controllers/roomController');
const { authenticate } = require('../middleware/auth');

router.post('/create', authenticate, roomController.createRoom);
router.post('/join/:roomId', authenticate, roomController.joinRoom);
router.post('/leave/:roomId', authenticate, roomController.leaveRoom);
router.get('/', authenticate, roomController.getRooms);
router.delete('/:roomId', authenticate, roomController.deleteRoom);
router.put('/:roomId', authenticate, roomController.editRoom);
router.get('/:roomId/members', authenticate, roomController.getRoomMembers);




module.exports = router;


==============================

-userRoutes.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');

router.post('/register', userController.register);
router.post('/login', userController.login);
router.post('/logout', userController.logout);


module.exports = router;


==============================

-server.js
require("dotenv").config();
const http = require("http");
const express = require("express");
const cors = require("cors");
const cookieParser = require('cookie-parser');
const userRoutes = require("./routes/userRoutes");
const chatRoutes = require("./routes/chatRoutes");
const roomRoutes = require("./routes/roomRoutes");
const { errorHandler } = require("./middleware/errorHandler");
//const rateLimiter = require("./middleware/rateLimit");
const User = require("./models/User");

process.on('unhandledRejection', (reason, promise) => {
  console.log('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (err, origin) => {
  console.log('Caught exception:', err, 'Exception origin:', origin);
});

const corsOptions = {
  origin: 'http://localhost:3000',
  credentials: true,
};

// Create Express app
const app = express();

// Add logging middleware
app.use((req, res, next) => {
  console.log(`Request received: ${req.method} ${req.path}`);
  next();
});

// Add Socket.IO instance to the request object
const server = http.createServer(app);
const io = require("./config/socket")(server, corsOptions);

app.use(cors(corsOptions));
app.use(express.json());
app.use(cookieParser());

//app.use('/api/chat/messages', rateLimiter)

// Add Socket.IO instance to the request object
app.use((req, res, next) => {
  req.io = io;
  next();
});

// Routes
app.use("/api/users", userRoutes);
app.use("/api/chat", chatRoutes);
app.use("/api/rooms", roomRoutes);

// Error handling middleware
app.use(errorHandler);

server.listen(process.env.PORT || 5000, () => {
  console.log(`Server running on port ${process.env.PORT || 5000}`);
});

==============================

-chat.test.js


==============================

-user.test.js


==============================

-chat.test.js


==============================

-user.test.js


==============================

-App.js
// App.js
import React, { useContext } from "react";
import { useLocation } from "react-router-dom";
import { Routes, Route, Link, Navigate } from "react-router-dom";
import Home from "./components/Home";

import { AuthContext } from "./contexts/AuthContext";
import LoginForm from "./components/LoginForm";
import RegisterForm from "./components/RegisterForm";
import ChatRoom from "./components/ChatRoom";
import RoomList from "./components/RoomList";
import CreateRoom from "./components/CreateRoom";
import ProtectedChatRoom from "./components/ProtectedChatRoom";
import LogoutButton from "./components/LogoutButton";
import PrivateChat from "./components/PrivateChat";

const MainApp = () => {
  const { user } = useContext(AuthContext);
  const location = useLocation();

  return (
    <div className="App">
      {user && <p>Welcome, {user.username}!</p>}
      {user && <LogoutButton />}
      <nav>
        <ul>
          {!user && (
            <>
              <li>
                <Link to="/login">Login</Link>
              </li>
              <li>
                <Link to="/register">Register</Link>
              </li>
              <li>
                <Link to="/">Home</Link>
              </li>
            </>
          )}
          {user && (
            <>
              <li>
                <Link to="/">Home</Link>
              </li>
              <li>
                <Link to="/rooms">Rooms</Link>
              </li>
            </>
          )}
        </ul>
      </nav>

      <Routes>
        <Route path="/login" element={<LoginForm />} />
        <Route path="/register" element={<RegisterForm />} />
        {user && (
          <>
            <Route path="/rooms/:roomId" element={<ProtectedChatRoom />} />
            <Route path="/private/:chatId" element={<PrivateChat user={user} />} />

            <Route
              path="/rooms"
              element={
                <>
                  <RoomList user={user} />
                  <CreateRoom user={user} />
                </>
              }
            />
          </>
        )}
        {user && <Route path="/" element={<Home />} />}
      </Routes>
    </div>
  );
};

export default MainApp;


==============================

-App.test.js
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


==============================

-ChatRoom.js
import React, { useState, useEffect } from "react";
import axios from "axios";
import io from "socket.io-client";
import { useParams } from "react-router-dom";

let socket;

const ChatRoom = ({ user }) => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const [members, setMembers] = useState([]);  
  const [onlineUsers, setOnlineUsers] = useState({}); // added this line to keep track of online users
  const { roomId } = useParams();

  useEffect(() => {
    socket = io('http://localhost:5000');
  
    socket.on('connect', () => {
      socket.emit('joinRoom', roomId, user.username); // added username parameter
    });

    const fetchMessages = async () => {
      if (roomId) {
        try {
          const res = await axios.get(
            `http://localhost:5000/api/chat/messages/${roomId}`,
            { withCredentials: true }
          );
          setMessages(res.data.messages);
        } catch (err) {
          console.error(err);
        }
      }
    };

    const fetchRoomMembers = async () => {
      if (roomId) {
        try {
          const res = await axios.get(
            `http://localhost:5000/api/rooms/${roomId}/members`,
            { withCredentials: true }
          );
          setMembers(res.data.members);
        } catch (err) {
          console.error(err);
        }
      }
    };

    fetchMessages();
    fetchRoomMembers();

    socket.on('receiveMessage', (message) => {
      setMessages((prevMessages) => [...prevMessages, message]);
    });

    // New code for handling userOnline and userOffline events
    socket.on('userOnline', (username) => {
      setOnlineUsers((prevUsers) => ({ ...prevUsers, [username]: true }));
    });

    socket.on('userOffline', (username) => {
      setOnlineUsers((prevUsers) => ({ ...prevUsers, [username]: false }));
    });

    return () => {
      socket.off("receiveMessage");
      socket.off("userOnline");
      socket.off("userOffline");
    };
  }, [roomId, user.username]);

  const sendMessage = async (e) => {
    e.preventDefault();
    try {
      const message = { text: newMessage, roomId, sender: user.username };
      socket.emit('sendMessage', message);
      setNewMessage("");
    } catch (err) {
      console.error(err);
    }
  };
  
  return (
    <div>
      <h2>Room: {roomId}</h2>
      <h3>Members:</h3>  
      <ul>
        {members.map((member, index) => (
          <li key={index}>
            {member} {onlineUsers[member] ? <span style={{color: "green"}}>â—‰</span> : <span style={{color: "red"}}>â—‰</span>}
          </li>
        ))}
      </ul>
      {messages.map((message, index) => (
        <div key={index}>
          <p>{message.text}</p>
          <p>By: {message.sender}</p>
        </div>
      ))}
      <form onSubmit={sendMessage}>
        <input
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          placeholder="Send a message"
        />
        <button type="submit">Send</button>
      </form>
    </div>
  );
};

export default ChatRoom;

==============================

-CreateRoom.js
// CreateRoom.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import UseAuth from '../hooks/UseAuth'; 
import { useNavigate } from 'react-router-dom';

const CreateRoom = () => {
  const [roomName, setRoomName] = useState('');
  const { user } = UseAuth();
  const navigate = useNavigate();

  useEffect(() => {
    // Redirect to login if user is not logged in
    if (!user) {
      navigate('/login');
    }
  }, [user, navigate]);

  const handleSubmit = async (event) => {
    event.preventDefault();

    try {
      const response = await axios.post('http://localhost:5000/api/rooms/create', 
        { name: roomName },
        { withCredentials: true }
      );
      console.log(response.data);
      setRoomName('');
    } catch (error) {
      console.error('Failed to create room:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={roomName}
        onChange={(event) => setRoomName(event.target.value)}
        placeholder="Room name"
        required
      />
      <button type="submit">Create Room</button>
    </form>
  );
};

export default CreateRoom;

==============================

-CreateRoomButton.js
-CreateRoomButton.js
import React, { useState } from "react";
import axios from "axios";

const CreateRoomButton = () => {
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [roomName, setRoomName] = useState("");

  const handleOpenForm = () => {
    setIsFormOpen(true);
  };

  const handleRoomNameChange = (event) => {
    setRoomName(event.target.value);
  };

  const handleSubmit = async (event) => {
    event.preventDefault();

    try {
      // Make a POST request to your server to create the room.
      // You'll need to replace this with your actual API call.
      await axios.post("/api/rooms/create", { name: roomName });

      // Close the form and clear the room name after successful creation.
      setIsFormOpen(false);
      setRoomName("");
    } catch (error) {
      console.error("Failed to create room:", error);
    }
  };

  return (
    <div>
      <button onClick={handleOpenForm}>Create Room</button>

      {isFormOpen && (
        <form onSubmit={handleSubmit}>
          <input
            type="text"
            value={roomName}
            onChange={handleRoomNameChange}
            placeholder="Room name"
            required
          />
          <button type="submit">Create</button>
        </form>
      )}
    </div>
  );
};

export default CreateRoomButton;

==============================

-Home.js
// Home.js
import React from 'react';

const Home = () => {
  return (
    <div>
      <h1>Welcome to Home!</h1>
      <p>This is the home page.</p>
    </div>
  );
};

export default Home;


==============================

-LoginForm.js
// LoginForm.js
import React, { useState, useContext } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../contexts/AuthContext';
import io from 'socket.io-client'; // Import socket.io-client

const LoginForm = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const { setUser } = useContext(AuthContext); // Ensure AuthContext provides setUser
  const navigate = useNavigate();
  const socket = io('http://localhost:5000'); // Create a socket instance

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await axios.post(
        'http://localhost:5000/api/users/login',
        { username, password },
        { withCredentials: true }
      );

      setUser({ username: response.data.username }); // Ensure response.data contains username

      // Emit login event
      socket.emit('login', response.data.username);

      navigate('/rooms');
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Username:
        <input
          type="text"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
      </label>
      <label>
        Password:
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
      </label>
      <button type="submit">Log in</button>
    </form>
  );
};

export default LoginForm;


==============================

-LogoutButton.js
// LogoutButton.js
import React from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import UseAuth from '../hooks/UseAuth';
import io from 'socket.io-client';  // Import socket.io-client

function LogoutButton() {
  const navigate = useNavigate();
  const { setUser } = UseAuth();
  const socket = io('http://localhost:5000');  // Create a socket instance

  const logout = async () => {
    try {
      const response = await axios.post('http://localhost:5000/api/users/logout', {}, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        withCredentials: true
      });
  
      setUser(null);

      // Emit logout event
      socket.emit('logout', response.data.username);  // Replace 'response.data.username' with the correct username
  
      navigate('/login');
    } catch (error) {
      console.error('Failed to log out', error);
    }
  };

  return (
    <button onClick={logout}>Logout</button>
  );
}

export default LogoutButton;

==============================

-PrivateChat.js
import React, { useState, useEffect } from "react";
import axios from "axios";
import io from "socket.io-client";
import { useParams } from "react-router-dom";

let socket;

const PrivateChat = ({ user }) => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const { chatId: encodedChatId } = useParams();
  const chatId = decodeURIComponent(encodedChatId); // Decode the chatId from URL parameters
  console.log("chatId from useParams:", chatId);

  useEffect(() => {
    socket = io("http://localhost:5000");

    socket.on("connect", () => {
      console.log(`Socket connected with ID: ${socket.id}`);
      socket.emit("login", user.id);
    });

    const fetchMessages = async () => {
      try {
        console.log(`Fetching messages for chatId: ${chatId}`);
        const receiverUsername = chatId
          .split("-")
          .find((username) => username !== user.username);
        const messageChatId = [user.username, receiverUsername]
          .sort()
          .join("-");

        console.log(`user.username: ${user.username}`);
        console.log(`receiverUsername: ${receiverUsername}`);
        console.log(`messageChatId: ${messageChatId}`);

        const res = await axios.get(
          `http://localhost:5000/api/chat/privateMessages/${messageChatId}`,
          { withCredentials: true }
        );

        setMessages(res.data.messages);
      } catch (err) {
        console.error(err);
      }
    };

    fetchMessages();

    socket.on("privateMessage", (message) => {
      console.log(`Received privateMessage event: ${JSON.stringify(message)}`);
      setMessages((prevMessages) => [...prevMessages, message]);
    });

    return () => {
      socket.off("privateMessage");
      socket.emit("logout", user.id);
      socket.close();
    };
  }, [chatId, user]);

  const sendMessage = async (e) => {
    e.preventDefault();
    try {
      const receiverUsername = chatId
        .split("-")
        .find((username) => username !== user.username);
      const messageChatId = [user.username, receiverUsername].sort().join("-");
      console.log(`Constructed chatId: ${messageChatId}`);

      const message = {
        text: newMessage,
        chatId: chatId, // Use the chatId from useParams()
        senderId: user.id,
        sender: user.username,
        timestamp: Date.now(),
        isUserSender: true,
      };

      console.log(
        `emit sendPrivateMessage with message: ${JSON.stringify(message)}`
      );

      socket.emit("sendPrivateMessage", message);
      console.log(`Sent message to server: ${JSON.stringify(message)}`);
      setMessages((prevMessages) => [...prevMessages, message]);
      setNewMessage("");
    } catch (err) {
      console.error(err);
    }
  };

  return (
    <div>
      <h2>
        Chat with:{" "}
        {chatId.split("-").find((username) => username !== user.username)}
      </h2>

      {messages.map((message, index) => (
        <div key={index}>
          <p>{message.text}</p>
          <p>By: {message.sender === user.username ? "You" : message.sender}</p>
        </div>
      ))}

      <form onSubmit={sendMessage}>
        <input
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          placeholder="Send a message"
        />
        <button type="submit">Send</button>
      </form>
    </div>
  );
};

export default PrivateChat;


==============================

-ProtectedChatRoom.js
// ProtectedChatRoom.js
import React from 'react';
import { Navigate, useParams } from 'react-router-dom';  // Import useParams
import UseAuth from '../hooks/UseAuth';
import ChatRoom from './ChatRoom';

const ProtectedChatRoom = () => {
  const { user } = UseAuth();  // Get the user from the Auth context
  const { roomId } = useParams();  // Get roomId from URL parameters

  // If there is no user logged in, redirect to login
  if (!user) {
    return <Navigate to="/login" />;
  }

  // If a user is logged in, render the ChatRoom
  return <ChatRoom user={user} roomId={roomId} />;  // Pass user and roomId as props
};

export default ProtectedChatRoom;

==============================

-ProtectedRoute.js
import React from 'react';
import { Route, useNavigate } from 'react-router-dom';
import UseAuth from '../hooks/UseAuth';

const ProtectedRoute = ({ component: Component, ...rest }) => {
  const { user } = UseAuth();
  const navigate = useNavigate();

  return (
    <Route
      {...rest}
      element={
        user ? <Component /> : (navigate('/login'), null)
      }
    />
  );
};

export default ProtectedRoute;

==============================

-RegisterForm.js
import React, { useState } from 'react';
import axios from 'axios';

function RegisterForm() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (event) => {
    event.preventDefault();
  
    try {
      await axios.post('http://localhost:5000/api/users/register', { username, password }, {
        withCredentials: true
      });
      alert('Registered successfully');
    } catch (error) {
      console.error('Failed to register', error.response.data);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Username:
        <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} />
      </label>
      <label>
        Password:
        <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
      </label>
      <button type="submit">Register</button>
    </form>
  );
}


export default RegisterForm;

==============================

-RoomList.js
// RoomList.js
import React, { useState, useEffect } from "react";
import axios from "axios";
import { useNavigate } from "react-router-dom";
import UseAuth from "../hooks/UseAuth";
import { Link } from "react-router-dom";

const RoomList = () => {
  const [rooms, setRooms] = useState([]);

  const navigate = useNavigate();
  const { user } = UseAuth();

  useEffect(() => {
    if (!user) {
      navigate("/login");
    } else {
      const fetchRooms = async () => {
        try {
          const res = await axios.get("http://localhost:5000/api/rooms", {
            withCredentials: true,
          });
          console.log(res.data.rooms); // Add this line
          setRooms(res.data.rooms);
        } catch (err) {
          console.error(err);
        }
      };

      fetchRooms();
    }
  }, [user, navigate]);

  const deleteRoom = async (roomId) => {
    try {
      await axios.delete(`http://localhost:5000/api/rooms/${roomId}`, {
        withCredentials: true,
      });
      // Refresh room list after deletion
      const res = await axios.get("http://localhost:5000/api/rooms", {
        withCredentials: true,
      });
      setRooms(res.data.rooms);
    } catch (err) {
      console.error(err);
    }
  };

  const joinRoom = async (roomId) => {
    try {
      await axios.post(
        `http://localhost:5000/api/rooms/join/${roomId}`,
        {},
        { withCredentials: true }
      );
      navigate(`/rooms/${roomId}`);
    } catch (err) {
      console.error(err);
    }
  };

  const leaveRoom = async (roomId) => {
    try {
      await axios.post(
        `http://localhost:5000/api/rooms/leave/${roomId}`,
        {},
        { withCredentials: true }
      );
      navigate(`/rooms`);
    } catch (err) {
      console.error(err);
    }
  };

  return user ? (
    <div>
      <h2>Chat Rooms</h2>
      {rooms.map((room) => (
        <div key={room.id}>
          <h3>
            <Link to={`/rooms/${room.id}`}>{room.name}</Link>
            {room.members.map(
              (member, index) =>
                member !== user.username && (
                  <Link
                    key={index}
                    to={`/private/${[user.username, member].sort().join("-")}`}
                  >
                    Private Chat with {member}
                  </Link>
                )
            )}
          </h3>
          <button onClick={() => joinRoom(room.id)}>Join Room</button>
          <button onClick={() => leaveRoom(room.id)}>Leave Room</button>
          <button onClick={() => deleteRoom(room.id)}>Delete Room</button>
        </div>
      ))}
    </div>
  ) : null;
};

export default RoomList;


==============================

-AuthContext.js
// AuthContext.js
import React, { createContext, useState } from 'react';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  return (
    <AuthContext.Provider value={{ user, setUser }}>
      {children}
    </AuthContext.Provider>
  );
};

==============================

-ChatContext.js
import { useContext } from 'react';
import { ChatContext } from '../contexts/ChatContext';

const useChat = () => {
  return useContext(ChatContext);
};

export default useChat;

import React, { createContext, useState } from 'react';

export const ChatContext = createContext();

export const ChatProvider = ({ children }) => {
  const [messages, setMessages] = useState([]);

  return (
    <ChatContext.Provider value={{ messages, setMessages }}>
      {children}
    </ChatContext.Provider>
  );
};

==============================

-UseAuth.js
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

const UseAuth = () => {
  
  return useContext(AuthContext);
};

export default UseAuth;

==============================

-UseChat.js
import { useContext } from 'react';
import { ChatContext } from '../contexts/ChatContext';

const useChat = () => {
  return useContext(ChatContext);
};

export default useChat;

==============================

-index.js
import React from 'react';
import ReactDOM from "react-dom/client";
import { BrowserRouter as Router } from 'react-router-dom';
import App from './App';
import { AuthProvider } from './contexts/AuthContext';
import reportWebVitals from "./reportWebVitals";


const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <AuthProvider>
      <Router>
        <App />
      </Router>
    </AuthProvider>
    </React.StrictMode>
);

reportWebVitals();


==============================

-reportWebVitals.js
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


==============================

-setupTests.js
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

