├── .git
├── README.md
├── backend
│   ├── .gitignore
│   ├── node_modules
│   ├── package-lock.json
│   ├── package.json
│   └── src
│       ├── .env
│       ├── config
│       │   ├── db.js
│       │   └── socket.js
│       ├── controllers
│       │   ├── chatController.js
│       │   ├── roomController.js
│       │   └── userController.js
│       ├── io.js
│       ├── middleware
│       │   ├── auth.js
│       │   └── errorHandler.js
│       ├── models
│       │   ├── Message.js
│       │   ├── Room.js
│       │   └── User.js
│       ├── node.js
│       ├── routes
│       │   ├── chatRoutes.js
│       │   ├── roomRoutes.js
│       │   └── userRoutes.js
│       ├── server.js
│       └── tests
│           ├── integration
│           │   ├── chat.test.js
│           │   └── user.test.js
│           └── unit
│               ├── chat.test.js
│               └── user.test.js
├── frontend
│   ├── .gitignore
│   ├── README.md
│   ├── node_modules
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   ├── favicon.ico
│   │   ├── index.html
│   │   ├── logo192.png
│   │   ├── logo512.png
│   │   ├── manifest.json
│   │   └── robots.txt
│   └── src
│       ├── App.css
│       ├── App.js
│       ├── App.test.js
│       ├── Home.css
│       ├── components
│       │   ├── ChatRoom.js
│       │   ├── CreateRoom.js
│       │   ├── Home.js
│       │   ├── LoginForm.js
│       │   ├── LogoutButton.js
│       │   ├── PrivateChat.js
│       │   ├── ProtectedChatRoom.js
│       │   ├── ProtectedRoute.js
│       │   ├── RegisterForm.js
│       │   ├── RoomList.js
│       │   └── media
│       │       ├── correct.svg
│       │       ├── delete.svg
│       │       └── leave.svg
│       ├── contexts
│       │   ├── AuthContext.js
│       │   ├── ChatContext.js
│       │   └── RoomsContext.js
│       ├── hooks
│       │   ├── UseAuth.js
│       │   └── UseChat.js
│       ├── index.css
│       ├── index.js
│       ├── logo.svg
│       ├── reportWebVitals.js
│       └── setupTests.js
├── source - Copy.txt
├── source copy.txt
├── source.txt
└── structure.py

==============================

-db.js
// Import the IORedis module.
const IORedis = require('ioredis');

// Initialize a new IORedis client with a configuration object.
// The configuration options (host, port, password) are fetched from environment variables.
const client = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

// Event listener for successful connection to Redis.
// Logs a success message to the console when the client successfully connects to the Redis server.
client.on('connect', () => {
  console.log('Connected to Redis...');
});

// Event listener for connection errors.
// Logs an error message to the console if an error occurs while trying to connect to the Redis server.
client.on('error', (err) => {
  console.log('Redis error: ', err);
});

// Export the client object for use in other parts of the application.
module.exports = client;


==============================

-socket.js
// Import necessary modules
const socketIo = require("socket.io");
const chatController = require("../controllers/chatController");
const Redis = require("ioredis");
const { RateLimiterRedis } = require("rate-limiter-flexible");

// Initialize Redis client with environment variables
const redisClient = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

// Initialize RateLimiter to control the request rate
const rateLimiter = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: "middleware",
  points: 10, // 10 requests
  duration: 60, // per 60 seconds by IP
});

// Maintain a mapping of user IDs to their socket IDs
const userSocketIds = {};

// Socket configuration
module.exports = (server, corsOptions) => {
  const io = socketIo(server, {
    cors: corsOptions,
  });

  // Handle new connections
  io.on('connection', (socket) => {
    console.log('New client connected:', socket.id);

    // Handle user login
    socket.on('login', (userId) => {
      console.log(`User logged in with ID: ${userId}, Socket ID: ${socket.id}`);
      userSocketIds[userId] = socket.id;
      socket.join(userId);
      socket.broadcast.emit('userOnline', userId); // Announce the user's online status
    });

    // Handle user logout
    socket.on('userLogout', (username) => {
      console.log(`User logged out with username: ${username}`);
      socket.broadcast.emit('userOffline', username); // Announce the user's offline status
    });

    // Handle disconnections
    socket.on('disconnect', () => {
      console.log('Client disconnected:', socket.id);
      
      // Find the user that got disconnected
      const disconnectedUser = Object.keys(userSocketIds).find(key => userSocketIds[key] === socket.id);
  
      // If a user was found, remove them from the mapping and announce their offline status
      if (disconnectedUser) {
        delete userSocketIds[disconnectedUser];
        socket.broadcast.emit('userOffline', disconnectedUser);
      }
    });

    // Handle message sending
    socket.on("sendMessage", async (message) => {
      console.log("Received sendMessage event with message", message);
      rateLimiter
        .consume(socket.id)
        .then(async () => {
          const req = {
            body: message,
            user: { username: message.sender },
            io: io,
          };
          try {
            const result = await chatController.sendMessage(req);
            console.log(result);
          } catch (error) {
            console.error(error.message);
          }
        })
        .catch((rejRes) => {
          console.log(`Rate limit exceeded for ${socket.id}. Remaining points: ${rejRes.remainingPoints}`);
        });
    });

    // Handle private message sending
    socket.on("sendPrivateMessage", async (message) => {
      console.log("Received sendPrivateMessage event with message", message);
      rateLimiter
        .consume(socket.id)
        .then(async () => {
          const req = {
            body: message,
            user: { id: message.senderId },
            io: io,
            userSocketIds: userSocketIds,
          };
          try {
            const result = await chatController.sendDirectMessage(req);
            console.log(result);

            // Emit the message to the receiver's room
            io.to(userSocketIds[message.receiverId]).emit(
              "privateMessage",
              result
            );
          } catch (error) {
            console.error(error.message);
          }
        })
        .catch((rejRes) => {
          console.log(`Rate limit exceeded for ${socket.id}. Remaining points: ${rejRes.remainingPoints}`);
        });
    });
  });

  return io;
};


==============================

-chatController.js
// Importing required models
const Message = require("../models/Message");
const Room = require("../models/Room");

// Controller to handle sending a message in a room
exports.sendMessage = async (req) => {
  const { text, roomId } = req.body;
  const { username } = req.user;

  // Check if the user is a member of the room
  const members = await Room.client.smembers(`room:${roomId}:members`);
  if (!members.includes(username)) {
    throw new Error("You are not a member of this room");
  }

  try {
    // Create a new message and save it in Redis
    const messageId = await Message.incr("message:id");
    const timestamp = Date.now();
    await Message.hset(
      `message:${messageId}`,
      "sender",
      username,
      "text",
      text,
      "timestamp",
      timestamp
    );
    await Message.lpush(`room:${roomId}:messages`, messageId);

    // Emit the 'receiveMessage' event to all clients
    const message = { id: messageId, sender: username, roomId, text, timestamp };
    req.io.emit("receiveMessage", message);

    return { status: 200, message: "Message sent successfully" };
  } catch (error) {
    console.error("Send message error:", error);
    throw new Error("An error occurred while sending the message");
  }
};

// Controller to get all messages from a room
exports.getMessages = async (req, res, next) => {
  const roomId = req.params.roomId;
  const { username } = req.user;

  // Check if the user is a member of the room
  const members = await Room.client.smembers(`room:${roomId}:members`);
  if (!members.includes(username)) {
    return res.status(403).json({ error: "You are not a member of this room" });
  }

  try {
    // Fetch all messages from the room and return
    const messageIds = await Message.lrange(`room:${roomId}:messages`, 0, -1);
    const messages = await Promise.all(
      messageIds.map(async (messageId) => {
        const message = await Message.hgetall(`message:${messageId}`);
        message.id = messageId;
        return message;
      })
    );

    res.status(200).json({ messages });
  } catch (error) {
    console.error("Get messages error:", error);
    res.status(500).json({ error: "An error occurred while getting the messages", details: error.message });
  }
};

// Controller to handle sending a direct message
exports.sendDirectMessage = async (req) => {
  const { text, sender, receiver } = req.body;

  // Compute the chatId
  const chatId = [sender, receiver].sort().join('-');

  try {
    // Create a new direct message and save it in Redis
    const messageId = await Message.incr("directMessage:id");
    const timestamp = Date.now();
    await Message.hset(
      `directMessage:${messageId}`,
      "sender",
      sender,
      "chatId",
      chatId,
      "text",
      text,
      "timestamp",
      timestamp,
      "status",
      "delivered"
    );
    await Message.lpush(`direct:${chatId}:messages`, messageId);

    // Emit the 'privateMessage' event to all clients
    const message = { id: messageId, sender, chatId, text, timestamp, status: "delivered" };
    req.io.emit("privateMessage", message);

    return { status: 200, message: "Message sent successfully" };
  } catch (error) {
    console.error("Send direct message error:", error);
    throw new Error("An error occurred while sending the message");
  }
};

// Controller to get all direct messages between two users
exports.getPrivateMessages = async (req, res, next) => {
  const chatId = req.params.chatId;

  try {
    // Fetch all direct messages between the two users and return
    const messageIds = await Message.lrange(`direct:${chatId}:messages`, 0, -1);
    const messages = await Promise.all(
      messageIds.map(async (messageId) => {
        const message = await Message.hgetall(`directMessage:${messageId}`);
        message.id = messageId;
        return message;
      })
    );

    res.status(200).json({ messages });
  } catch (error) {
    console.error("Get private messages error:", error);
    res.status(500).json({ error: "An error occurred while getting the messages", details: error.message });
  }
};

// Controller to get all direct messages in a conversation
exports.getConversation = async (req, res, next) => {
  const { id: senderId } = req.user;
  const { receiverId } = req.params;

  // Ensure the chatId is always the same regardless of who is the sender and receiver
  const [user1, user2] = [senderId, receiverId].sort();

  try {
    // Fetch all messages in the conversation and return
    const messageIds = await Message.lrange(`direct:${user1}:${user2}:messages`, 0, -1);
    const messages = await Promise.all(
      messageIds.map(async (messageId) => {
        const message = await Message.hgetall(`directMessage:${messageId}`);
        message.id = messageId;
        return message;
      })
    );

    res.status(200).json({ messages });
  } catch (error) {
    console.error("Get conversation error:", error);
    res.status(500).json({ error: "An error occurred while getting the conversation", details: error.message });
  }
};

// Controller to update the status of a message
exports.updateMessageStatus = async (req, res, next) => {
  const { messageId, status } = req.body;

  try {
    // Update the status of the message in Redis
    await Message.hset(`directMessage:${messageId}`, "status", status);

    // Emit the 'updateMessageStatus' event to all clients
    const message = await Message.hgetall(`directMessage:${messageId}`);
    const updatedMessage = { id: messageId, sender: message.sender, chatId: message.chatId, text: message.text, timestamp: message.timestamp, status };
    req.io.emit("updateMessageStatus", updatedMessage);

    res.status(200).json({ message: "Message status updated successfully" });
  } catch (error) {
    console.error("Update message status error:", error);
    res.status(500).json({ error: "An error occurred while updating the message status", details: error.message });
  }
};


==============================

-roomController.js
// Import the Room model
const Room = require('../models/Room');

// Function to handle GET request for room members
exports.getRoomMembers = async (req, res, next) => {
  const { roomId } = req.params;

  try {
    // Fetch members from Redis store
    const members = await Room.client.smembers(`room:${roomId}:members`);
    // Return members list in response
    res.status(200).json({ members });
  } catch (error) {
    console.error('Error in fetching room members:', error);
    next(error);
  }
};

// Function to handle POST request for room creation
exports.createRoom = async (req, res, next) => {
  const { name } = req.body;

  try {
    // Call the createRoom method of the Room model
    const roomId = await Room.createRoom(name);
    // Return a success message and room details in response
    res.status(201).json({
      message: 'Room created successfully',
      room: { id: roomId, name: name }
    });
  } catch (error) {
    console.error('Error in creating room:', error);
    next(error);
  }
};

// Function to handle PUT request for joining a room
exports.joinRoom = async (req, res, next) => {
  const { roomId } = req.params;
  const { username } = req.user;

  try {
    // Call the joinRoom method of the Room model
    await Room.joinRoom(roomId, username);
    // Return a success message in response
    res.status(200).json({ message: 'Joined room successfully' });
  } catch (error) {
    console.error('Error in joining room:', error);
    next(error);
  }
};

// Function to handle PUT request for leaving a room
exports.leaveRoom = async (req, res, next) => {
  const { roomId } = req.params;
  const { username } = req.user;

  try {
    // Call the leaveRoom method of the Room model
    await Room.leaveRoom(roomId, username);
    // Return a success message in response
    res.status(200).json({ message: 'Left room successfully' });
  } catch (error) {
    console.error('Error in leaving room:', error);
    next(error);
  }
};

// Function to handle GET request for list of rooms
exports.getRooms = async (req, res, next) => {
  try {
    // Call the getRooms method of the Room model
    const rooms = await Room.getRooms();
    // Return list of rooms in response
    res.status(200).json({ rooms });
  } catch (error) {
    console.error('Error in fetching rooms:', error);
    next(error);
  }
};

// Function to handle DELETE request for a room
exports.deleteRoom = async (req, res, next) => {
  const { roomId } = req.params;

  try {
    // Call the deleteRoom method of the Room model
    await Room.deleteRoom(roomId);
    // Return a success message in response
    res.status(200).json({ message: 'Room deleted successfully' });
  } catch (error) {
    console.error('Error in deleting room:', error);
    next(error);
  }
};

// Function to handle PUT request for editing a room
exports.editRoom = async (req, res, next) => {
  const { roomId } = req.params;
  const { newName } = req.body;

  try {
    // Call the editRoom method of the Room model
    await Room.editRoom(roomId, newName);
    // Return a success message in response
    res.status(200).json({ message: 'Room edited successfully' });
  } catch (error) {
    console.error('Error in editing room:', error);
    next(error);
  }
};


==============================

-userController.js
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const User = require("../models/User");
const IORedis = require("ioredis");
let redis = User.client;

exports.register = async (req, res, next) => {
  const { username, password } = req.body;

  try {
    const userExists = await User.verifyUser(username);
    if (userExists) {
      return res.status(400).json({ error: "Username already taken" });
    }

    await User.addUser(username, password);

    res.status(201).json({ message: "User registered successfully" });
  } catch (error) {
    console.error("Registration error:", error);
    next(error);
  }
};

exports.login = async (req, res, next) => {
  const { username, password } = req.body;

  try {
    const user = await User.getUser(username);

    if (!user || !user.password) {
      return res.status(400).json({ error: "User does not exist" });
    }

    const validPassword = await bcrypt.compare(password, user.password);

    if (!validPassword) {
      return res.status(400).json({ error: "Invalid password" });
    }

    if (!process.env.JWT_SECRET) {
      console.error("JWT_SECRET is not defined in the environment variables.");
      return res.status(500).json({ error: "Internal server error" });
    }

    const token = jwt.sign({ username }, process.env.JWT_SECRET, {
      expiresIn: "1h",
    });

    // Set the JWT token in an HTTP-only cookie
    res.cookie("token", token, {
      httpOnly: true,
      sameSite: "strict", // or 'lax' depending on your needs
      secure: false, // set this to true if your website runs on https, otherwise set it to false
      maxAge: 3600000, // token expiration time in milliseconds, this is equal to 1 hour
    });

    res.status(200).json({ message: "User logged in successfully", username });
  } catch (error) {
    console.error("Login error:", error);
    next(error);
  }
};

exports.logout = async (req, res, next) => {
  // Add the existing token to the invalidated tokens set
  const token = req.cookies.token;
  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  if (!req.user || !req.user.username) {
    return res.status(400).json({ error: "Invalid user" });
  }

  try {
    await redis.sadd("invalidatedTokens", token);

    // Clear the token cookie
    res.clearCookie("token");

    // Emit logout event
    const io = require("../io"); // Import io from your io.js file
    io.emit("logout", req.user.username); // assuming req.user.username is available

    res.status(200).json({ message: "User logged out successfully" });
  } catch (error) {
    console.error("Logout error:", error);
    next(error);
  }
};


==============================

-io.js
require("dotenv").config();
const http = require("http");
const express = require("express");
const cors = require("cors");
const cookieParser = require('cookie-parser');
const userRoutes = require("./routes/userRoutes");
const chatRoutes = require("./routes/chatRoutes");
const roomRoutes = require("./routes/roomRoutes");
const { errorHandler } = require("./middleware/errorHandler");
//const rateLimiter = require("./middleware/rateLimit");
const User = require("./models/User");

process.on('unhandledRejection', (reason, promise) => {
  console.log('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (err, origin) => {
  console.log('Caught exception:', err, 'Exception origin:', origin);
});

const corsOptions = {
  origin: 'http://localhost:3000',
  credentials: true,
};

// Create Express app
const app = express();

// Add logging middleware
app.use((req, res, next) => {
  console.log(`Request received: ${req.method} ${req.path}`);
  next();
});

// Add Socket.IO instance to the request object
const server = http.createServer(app);
const io = require("./config/socket")(server, corsOptions);

app.use(cors(corsOptions));
app.use(express.json());
app.use(cookieParser());

//app.use('/api/chat/messages', rateLimiter)

// Add Socket.IO instance to the request object
app.use((req, res, next) => {
  req.io = io;
  next();
});

// Routes
app.use("/api/users", userRoutes);
app.use("/api/chat", chatRoutes);
app.use("/api/rooms", roomRoutes);

// Error handling middleware
app.use(errorHandler);

server.listen(process.env.PORT || 5000, () => {
  console.log(`Server running on port ${process.env.PORT || 5000}`);
});

// io.js
const socketIo = require('socket.io');

module.exports = function(server) {
  const io = socketIo(server);

  io.on('connection', (socket) => {
    console.log('New client connected');

    socket.on('joinRoom', (roomId) => {
      socket.join(roomId);
    });

    socket.on('leaveRoom', (roomId) => {
      socket.leave(roomId);
    });

    socket.on('sendMessage', (message) => {
      io.to(message.roomId).emit('receiveMessage', message);
    });

    socket.on('updateMessageStatus', async ({ messageId, status }) => {
      console.log(`Received updateMessageStatus event from client with message ID: ${messageId} and status: ${status}`);
      
      try {
        // Update the message status in the database
        await Message.hset(`directMessage:${messageId}`, 'status', status);
        console.log(`Updated status of message ${messageId} to ${status}`);
        
        // Emit an updateMessageStatus event back to the clients with the updated message status
        io.emit('updateMessageStatus', { messageId, status });
      } catch (error) {
        console.error('Error updating message status:', error);
      }
    });
    
    

    socket.on('disconnect', () => {
      console.log('Client disconnected');
    });
  });

  return io;
};
module.exports = io;


==============================

-auth.js
// Import required modules
const jwt = require('jsonwebtoken');
const IORedis = require('ioredis');

// Initialize a new Redis client
const client = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

// Middleware function to authenticate the user
exports.authenticate = async (req, res, next) => {
  // Retrieve the token from the request cookies
  const token = req.cookies.token;

  // If no token is provided, return an error
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  // Check if the token has been invalidated
  const isInvalidated = await client.sismember("invalidatedTokens", token);
  
  // If the token is invalidated, return an error
  if (isInvalidated) {
    return res.status(401).json({ error: 'The token is invalidated' });
  }

  // If the JWT_SECRET environment variable is not defined, return an error
  if (!process.env.JWT_SECRET) {
    return res.status(500).json({ error: 'Internal server error' });
  }

  try {
    // Verify the JWT token and extract the user information
    const user = jwt.verify(token, process.env.JWT_SECRET);

    // Assign the user object to the request object
    req.user = user;

    // Continue to the next middleware function
    next();
  } catch (error) {
    // If the JWT verification fails, return an error
    return res.status(401).json({ error: 'Invalid token' });
  }
};


==============================

-errorHandler.js
/**
 * A middleware function to handle errors that occur in the application.
 * It logs the error and sends a response with status 500 and the error message.
 * 
 * @param {Error} err - The error object
 * @param {Request} req - The Express request object
 * @param {Response} res - The Express response object
 * @param {Function} next - The next middleware function in the Express pipeline
 */
exports.errorHandler = (err, req, res, next) => {
  // Log the error to the console for debugging purposes
  console.error(err);

  // Respond to the client with a 500 status code and the error message
  res.status(500).json({ error: err.message });
};


==============================

-Message.js
// Import the ioredis library
const IORedis = require("ioredis");

// Create a new Redis client
const messageClient = new IORedis({
  // Provide Redis server host, port, and password from environment variables
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
  
  // Setup a retry strategy for reconnecting to the Redis server if the connection is lost
  // The delay for each retry attempt increases linearly (times * 50) but is capped at 2000 milliseconds
  retryStrategy: function (times) {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
});

// Set up an error event listener on the Redis client to log any errors
messageClient.on("error", (err) => {
  console.log("Error", err);
});

// The data structure for messages stored in Redis includes the following fields:
// id - Automatically generated by Redis
// sender - The sender of the message
// text - The content of the message
// timestamp - The time when the message was sent

// Export the Redis client for use in other parts of the application
module.exports = messageClient;


==============================

-Room.js
// Import the IORedis library
const IORedis = require('ioredis');

// Initialize a new Redis client
// The 'retryStrategy' option is a function that's called when the client loses the connection to the Redis server
// It returns the delay amount in milliseconds to use before reconnecting. If no value is returned, the client will stop trying to reconnect
const client = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
  retryStrategy: times => Math.min(times * 50, 2000),
});

// Event listener for successful connection to the Redis server
client.on('connect', () => {
  console.log('Redis client connected');
});

// Event listener for connection errors with the Redis server
client.on('error', err => {
  console.log('Error', err);
});

// Functions that manipulate the 'Room' data in Redis
// Create a new room with a specified name
async function createRoom(name) {
  const roomId = await client.incr('room:id');
  await client.hset(`room:${roomId}`, 'name', name);
  await client.sadd('rooms', roomId);
  return roomId;
}

// Add a user to a specified room
async function joinRoom(roomId, username) {
  await client.sadd(`room:${roomId}:members`, username);
}

// Remove a user from a specified room
async function leaveRoom(roomId, username) {
  await client.srem(`room:${roomId}:members`, username);
}

// Retrieve all rooms
async function getRooms() {
  const roomIds = await client.smembers('rooms');
  const rooms = [];

  // Iterate over each room and fetch the room details and its members
  for (let roomId of roomIds) {
    const room = await client.hgetall(`room:${roomId}`);
    room.members = await client.smembers(`room:${roomId}:members`);
    room.id = roomId;
    rooms.push(room);
  }
  return rooms;
}

// Delete a specified room
async function deleteRoom(roomId) {
  await client.del(`room:${roomId}`);
  await client.srem('rooms', roomId);
}

// Rename a specified room
async function editRoom(roomId, newName) {
  await client.hset(`room:${roomId}`, 'name', newName);
}

// Export the functions for use in other files
module.exports = {
  createRoom,
  joinRoom,
  leaveRoom,
  getRooms,
  deleteRoom,
  editRoom,
  client,
};


==============================

-User.js
// Required packages
const IORedis = require("ioredis");
const bcrypt = require("bcrypt");

// Create a Redis client
// The `retryStrategy` function is used to control how often and when to retry connecting.
// The delay between retries is calculated as a minimum of the retry attempt times 50 and 2000 milliseconds.
const redisClient = new IORedis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
  retryStrategy: function (times) {
    return Math.min(times * 50, 2000);
  },
});

// Event listeners for the Redis client.
// On 'connect', the client will log a success message.
redisClient.on("connect", () => {
  console.log("Successfully connected to Redis");
});

// On 'error', the client will log the error.
redisClient.on("error", (err) => {
  console.error("Redis error:", err);
});

// A helper function to hash a password using bcrypt.
async function hashPassword(password) {
  const salt = await bcrypt.genSalt(10);
  return await bcrypt.hash(password, salt);
}

// A function to add a new user to the Redis store.
// The user's password is hashed before being stored.
async function addUser(username, password) {
  const hashedPassword = await hashPassword(password);
  await redisClient.hset(`user:${username}`, "password", hashedPassword);
}

// A function to verify if a user exists in the Redis store.
// It checks if the 'password' field of the user exists.
async function verifyUser(username) {
  const password = await redisClient.hget(`user:${username}`, 'password');
  return password !== null;
}

// A function to retrieve a user's data from the Redis store.
async function getUser(username) {
  return await redisClient.hgetall(`user:${username}`);
}

// Expose the Redis client and helper functions as a module.
module.exports = {
  addUser,
  verifyUser,
  getUser,
  client: redisClient,
};


==============================

-node.js
// Require the dotenv module to load environment variables from a .env file into process.env
require("dotenv").config();

// Import the ioredis module for Redis connection
const Redis = require("ioredis");

// Initialize the Redis client with configuration from environment variables
const redis = new Redis({
  host: process.env.REDIS_HOST,  // The host of the Redis server
  port: process.env.REDIS_PORT,  // The port of the Redis server
  password: process.env.REDIS_PASSWORD,  // The password for the Redis server
});

// Set up an event listener for successful Redis connection
redis.on("connect", () => {
  console.log("Redis client connected");
});

// Set up an event listener for Redis connection error
redis.on("error", (err) => {
  console.error("Redis error:", err);
});

// Keep the script running until manually stopped
// This is done by setting an interval that does nothing but keeps the event loop busy
setInterval(() => {}, 1000);


==============================

-chatRoutes.js
// Importing required modules
const express = require("express");
const router = express.Router();
const chatController = require("../controllers/chatController");
const { authenticate } = require("../middleware/auth");
const rateLimit = require("express-rate-limit");

// Setting up rate limiting to prevent abuse. Each IP is limited to 3 requests every 15 minutes
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 3, 
  message: "Too many messages created from this IP, please try again after an hour",
});

// Route for sending a message in a chat room. Authentication and rate limiting middleware are applied
router.post("/send", authenticate, apiLimiter, chatController.sendMessage);

// Route for sending a direct message. Authentication and rate limiting middleware are applied
router.post("/sendDirect", authenticate, apiLimiter, chatController.sendDirectMessage);

// Route for fetching messages from a room. Authentication middleware is applied
router.get("/messages/:roomId", authenticate, chatController.getMessages);

// Route for fetching private messages from a chat. Authentication middleware is applied
router.get("/privateMessages/:chatId", authenticate, chatController.getPrivateMessages);

// Route for fetching a conversation with a specific receiver. Authentication middleware is applied
router.get('/conversation/:receiverId', authenticate, chatController.getConversation);

// Route for fetching the last read message in a chat. The route is asynchronous as it involves fetching data from Redis
router.get('/lastReadMessage/:userId/:chatId', async (req, res, next) => {
  const { userId, chatId } = req.params;
  const readMessagesKey = `readMessages:${userId}:${chatId}`;
  const lastReadMessageId = await client.get(readMessagesKey);
  res.json(lastReadMessageId || null);
});

// Exporting the router to be used in other modules
module.exports = router;


==============================

-roomRoutes.js
// Import necessary modules
const express = require('express');
const roomController = require('../controllers/roomController');
const { authenticate } = require('../middleware/auth');

// Initialize Express router
const router = express.Router();

// Define endpoint for creating a new room
// This route requires authentication
router.post('/create', authenticate, roomController.createRoom);

// Define endpoint for joining a room by ID
// This route requires authentication
router.post('/join/:roomId', authenticate, roomController.joinRoom);

// Define endpoint for leaving a room by ID
// This route requires authentication
router.post('/leave/:roomId', authenticate, roomController.leaveRoom);

// Define endpoint for getting all rooms
// This route requires authentication
router.get('/', authenticate, roomController.getRooms);

// Define endpoint for deleting a room by ID
// This route requires authentication
router.delete('/:roomId', authenticate, roomController.deleteRoom);

// Define endpoint for editing a room by ID
// This route requires authentication
router.put('/:roomId', authenticate, roomController.editRoom);

// Define endpoint for getting all members of a room by ID
// This route requires authentication
router.get('/:roomId/members', authenticate, roomController.getRoomMembers);

// Export the router to be used in other parts of the application
module.exports = router;


==============================

-userRoutes.js
// Import the required modules
const express = require('express');
const userController = require('../controllers/userController');
const auth = require('../middleware/auth');

// Initialize a router instance
const router = express.Router();

// Define the route for user registration. This route is handled by the register function in the userController.
router.post('/register', userController.register);

// Define the route for user login. This route is handled by the login function in the userController.
router.post('/login', userController.login);

// Define the route for user logout. This route is protected by the authentication middleware, so only logged-in users can access it.
// The auth.authenticate middleware function is called before the logout function in the userController. If the user is not authenticated, they will not be able to logout.
router.post('/logout', auth.authenticate, userController.logout);

// Export the router instance, which will be used in other parts of the application to handle user-related routes.
module.exports = router;


==============================

-server.js
// Import necessary dependencies
require("dotenv").config();
const http = require("http");
const express = require("express");
const cors = require("cors");
const cookieParser = require('cookie-parser');

// Import routes
const userRoutes = require("./routes/userRoutes");
const chatRoutes = require("./routes/chatRoutes");
const roomRoutes = require("./routes/roomRoutes");

// Import middleware
const { errorHandler } = require("./middleware/errorHandler");

// Process-level error handlers
process.on('unhandledRejection', (reason, promise) => {
  console.log('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (err, origin) => {
  console.log('Caught exception:', err, 'Exception origin:', origin);
});

// CORS configuration
const corsOptions = {
  origin: 'http://localhost:3000',
  credentials: true,
};

// Create Express app
const app = express();

// Middleware for logging incoming requests
app.use((req, res, next) => {
  console.log(`Request received: ${req.method} ${req.path}`);
  next();
});

// Create server with Socket.IO and CORS configuration
const server = http.createServer(app);
const io = require("./config/socket")(server, corsOptions);

// Express middleware configuration
app.use(cors(corsOptions));  // Enable CORS with the given options
app.use(express.json());  // Enable JSON request body parsing
app.use(cookieParser());  // Enable cookie parsing

// Middleware to attach Socket.IO instance to the request object
app.use((req, res, next) => {
  req.io = io;
  next();
});

// Routing
app.use("/api/users", userRoutes);  // User-related routes
app.use("/api/chat", chatRoutes);  // Chat-related routes
app.use("/api/rooms", roomRoutes);  // Room-related routes

// Error handling middleware
app.use(errorHandler);

// Start the server
server.listen(process.env.PORT || 5000, () => {
  console.log(`Server running on port ${process.env.PORT || 5000}`);
});


==============================

-chat.test.js


==============================

-user.test.js


==============================

-chat.test.js


==============================

-user.test.js


==============================

-App.js
// App.js
import React, { useContext, useState } from "react";
import { useLocation } from "react-router-dom";
import { Routes, Route, Link, Navigate } from "react-router-dom";
import Home from "./components/Home";

import { AuthContext } from "./contexts/AuthContext";
import { RoomsContext } from "./contexts/RoomsContext";
import LoginForm from "./components/LoginForm";
import RegisterForm from "./components/RegisterForm";
import ChatRoom from "./components/ChatRoom";
import RoomList from "./components/RoomList";
import CreateRoom from "./components/CreateRoom";
import ProtectedChatRoom from "./components/ProtectedChatRoom";
import LogoutButton from "./components/LogoutButton";
import PrivateChat from "./components/PrivateChat";
import { RoomsProvider } from './contexts/RoomsContext';
import "./App.css";

const MainApp = () => {
  const { user } = useContext(AuthContext);
  const location = useLocation();

  // Initialize rooms as an empty array
  const [rooms, setRooms] = useState([]);

  return (
    <RoomsContext.Provider value={{ rooms, setRooms }}>
      <div className="App">
        {user && <p>Welcome, {user.username}!</p>}
        {user && <LogoutButton />}
        <nav>
          <ul>
            {!user && (
              <>
                <li>
                  <Link to="/login">Login</Link>
                </li>
                <li>
                  <Link to="/register">Register</Link>
                </li>
                <li>
                  <Link to="/">Home</Link>
                </li>
              </>
            )}
            {user && (
              <>
                <li>
                  <Link to="/">Home</Link>
                </li>
                <li>
                  <Link to="/rooms">Rooms</Link>
                </li>
              </>
            )}
          </ul>
        </nav>

        <Routes>
          <Route path="/login" element={<LoginForm />} />
          <Route path="/register" element={<RegisterForm />} />
          {user && (
            <>
              <Route path="/private/:chatId" element={<PrivateChat user={user} />} />

              <Route
                path="/rooms"
                element={
                  <>
                    <RoomList user={user} />
                    <CreateRoom user={user} />
                  </>
                }
              />
            </>
          )}
          {user && <Route path="/" element={<Home />} />}
        </Routes>
      </div>
    </RoomsContext.Provider>
  );
};

export default MainApp;

==============================

-App.test.js
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


==============================

-ChatRoom.js
// Required Libraries
import React, { useState, useEffect, useRef } from "react";
import axios from "axios";
import io from "socket.io-client";
import "../App.css";

let socket;

// ChatRoom component
const ChatRoom = ({ user, roomId, roomName, members = [], setMembers }) => {

  // Initializing states
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const [onlineUsers, setOnlineUsers] = useState({});
  const messagesEndRef = useRef(null);

  // Function for smooth scrolling to the bottom of the chat
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  // Scroll to bottom whenever messages update
  useEffect(scrollToBottom, [messages]);

  // When roomId or username changes, create a new socket connection and fetch initial messages and members
  useEffect(() => {

    // Initialize socket connection
    socket = io("http://localhost:5000");

    // On connection, join the room with username
    socket.on("connect", () => {
      socket.emit("joinRoom", roomId, user.username);
    });

    // Fetch all messages for the room
    const fetchMessages = async () => {
      if (roomId) {
        try {
          const res = await axios.get(`http://localhost:5000/api/chat/messages/${roomId}`, { withCredentials: true });
          setMessages(res.data.messages.map((message) => {
            return {
              ...message,
              isUserSender: message.sender === user.username,
              alignment: message.sender === user.username ? "align-right" : "align-left",
              name: message.sender,
              time: new Date(message.timestamp).toLocaleTimeString(),
              id: message._id,
              meOrNot: message.sender === user.username ? "me" : "not-me",
              otherOrMy: message.sender === user.username ? "my" : "other",
            };
          }).reverse());
        } catch (err) {
          console.error(err);
        }
      }
    };

    // Fetch all members for the room
    const fetchRoomMembers = async () => {
      if (roomId) {
        try {
          const res = await axios.get(`http://localhost:5000/api/rooms/${roomId}/members`, { withCredentials: true });
          setMembers(res.data.members);
        } catch (err) {
          console.error(err);
        }
      }
    };

    // Fetch initial data
    fetchMessages();
    fetchRoomMembers();

    // Socket events handlers
    socket.on("receiveMessage", (message) => {
      setMessages((prevMessages) => [...prevMessages, {
        ...message,
        isUserSender: message.sender === user.username,
        alignment: message.sender === user.username ? "align-right" : "align-left",
        name: message.sender,
        time: new Date(message.timestamp).toLocaleTimeString(),
        id: message._id,
        meOrNot: message.sender === user.username ? "me" : "not-me",
        otherOrMy: message.sender === user.username ? "my" : "other",
      }]);
    });

    socket.on("userOnline", (username) => {
      setOnlineUsers((prevUsers) => ({ ...prevUsers, [username]: true }));
    });

    socket.on("userOffline", (username) => {
      setOnlineUsers((prevUsers) => ({ ...prevUsers, [username]: false }));
    });

    // Cleanup function when the component unmounts or roomId/username changes
    return () => {
      socket.off("receiveMessage");
      socket.off("userOnline");
      socket.off("userOffline");
    };
  }, [roomId, user.username]);

  // Function to send a message
  const sendMessage = async (e) => {
    e.preventDefault();

    if (newMessage.trim() !== "") {
      try {
        const message = {
          text: newMessage,
          roomId: roomId,
          sender: user.username,
          timestamp: Date.now(),
          isUserSender: true,
        };

        socket.emit("sendMessage", message);
        setNewMessage("");
      } catch (err) {
        console.error(err);
      }
    }
  };

  // Handlers for input change and keydown events
  const handleInputChange = (e) => {
    setNewMessage(e.target.value);
  };

  const handleKeyDown = (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      if (!e.shiftKey) {
        sendMessage(e);
      }
    }
  };

  // Rendering chat component
  return (
    <div className="chat">
      <div className="chat-header clearfix">
        <div className="chat-about">
          <div className="chat-with">Room: {roomName}</div>
        </div>
      </div>

      <div className="chat-history">
        <ul>
          {messages.map((message) => (
            <li className="clearfix" key={message.id}>
              <div className={`message-data ${message.alignment}`}>
                <span className="message-data-name">
                  {message.isUserSender ? "You" : message.sender}
                </span>{" "}
                <i className={`fa fa-circle ${message.meOrNot}`}></i>
              </div>
              <div className={`message ${message.otherOrMy}-message float-right`}>
                {message.text}
              </div>
            </li>
          ))}
        </ul>
      </div>

      <div className="chat-message clearfix">
        <form onSubmit={sendMessage}>
          <textarea
            name="message-to-send"
            id="message-to-send"
            placeholder="Type your message"
            rows="1"
            value={newMessage}
            onChange={handleInputChange}
            onKeyDown={handleKeyDown}
          ></textarea>
          <button type="submit">Send</button>
        </form>
      </div>
    </div>
  );
};

export default ChatRoom;


==============================

-CreateRoom.js
// Importing required modules and context
import React, { useContext, useState } from 'react';
import axios from 'axios';
import { RoomsContext } from '../contexts/RoomsContext';

const CreateRoom = () => {
  // Using React's useState hook to manage roomName state
  const [roomName, setRoomName] = useState('');
  
  // Using React's useContext hook to access RoomsContext
  const { setRooms } = useContext(RoomsContext);

  // Defining a function to handle form submission
  const handleSubmit = async (event) => {
    // Preventing the default action of form submission
    event.preventDefault();

    try {
      // Making a POST request to the server to create a new room
      const response = await axios.post('http://localhost:5000/api/rooms/create', 
        { name: roomName }, // Sending roomName as part of the request body
        { withCredentials: true } // Sending cookies along with the request
      );

      // Logging the response data
      console.log(response.data);

      // Fetching rooms again after creating a new room
      const roomsResponse = await axios.get('http://localhost:5000/api/rooms', { withCredentials: true });
      
      // Updating the rooms state
      setRooms(roomsResponse.data.rooms);

      // Clearing the roomName input field after successful creation
      setRoomName('');
    } catch (error) {
      // Logging the error in case room creation fails
      console.error('Failed to create room:', error);
    }
  };

  // Rendering the form
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={roomName}
        onChange={(event) => setRoomName(event.target.value)} // Updating roomName state every time the input field changes
        placeholder="Room name"
        required
      />
      <button type="submit">Create Room</button>
    </form>
  );
};

// Exporting CreateRoom component
export default CreateRoom;


==============================

-Home.js
// Home.js
import React from 'react';

const Home = () => {
  return (
    <div>
      <h1>Welcome to Home!</h1>
      <p>This is the home page.</p>
    </div>
  );
};

export default Home;


==============================

-LoginForm.js
// Import the necessary modules.
import React, { useState, useContext } from 'react';  // React and its hooks.
import axios from 'axios';  // Axios to make HTTP requests.
import { useNavigate } from 'react-router-dom';  // Navigation hook from react-router.
import { AuthContext } from '../contexts/AuthContext';  // Auth context to handle authentication.

// LoginForm component definition.
const LoginForm = () => {
  // State variables for username and password.
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  // Fetch login function from auth context.
  const { login } = useContext(AuthContext);

  // Fetch navigate function from router.
  const navigate = useNavigate();

  // Form submission handler.
  const handleSubmit = async (e) => {
    // Prevent default form submission behavior.
    e.preventDefault();

    try {
      // Make a POST request to the login API endpoint with the username and password.
      const response = await axios.post(
        'http://localhost:5000/api/users/login',
        { username, password },
        { withCredentials: true }
      );

      // If successful, call the login function from the auth context with the returned username and navigate to the rooms route.
      login(response.data.username);
      navigate('/rooms');
    } catch (error) {
      // Log any errors to the console.
      console.error(error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Username:
        <input
          type="text"
          value={username}
          // Update the username state variable on change.
          onChange={(e) => setUsername(e.target.value)}
        />
      </label>
      <label>
        Password:
        <input
          type="password"
          value={password}
          // Update the password state variable on change.
          onChange={(e) => setPassword(e.target.value)}
        />
      </label>
      <button type="submit">Log in</button>
    </form>
  );
};

export default LoginForm;


==============================

-LogoutButton.js
// Importing necessary libraries and hooks
import React from 'react';
import { useNavigate } from 'react-router-dom';  // React Router's hook for navigation
import axios from 'axios';  // HTTP client for the browser and node.js
import { AuthContext } from '../contexts/AuthContext';  // Context for Auth

// The LogoutButton component
function LogoutButton() {
  // useNavigate hook for navigation
  const navigate = useNavigate();

  // useContext hook to access the AuthContext
  const { logout, user } = React.useContext(AuthContext);

  // Function for handling the logout
  const handleLogout = async () => {
    try {
      // Making a POST request to the logout API
      await axios.post(
        'http://localhost:5000/api/users/logout',
        {},
        {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}` // Access token for authentication
          },
          withCredentials: true // Enables automatic sending of cookies
        }
      );
  
      // Calling the logout method from AuthContext
      logout();

      // Navigating to the login page after successful logout
      navigate('/login');
    } catch (error) {
      // Logging any error occurred during the process
      console.error('Failed to log out', error);
    }
  };
  
  // Rendering the Logout button
  return (
    <button onClick={handleLogout}>Logout</button>
  );
}

export default LogoutButton;


==============================

-PrivateChat.js
import React, { useState, useEffect, useRef } from "react";
import axios from "axios";
import io from "socket.io-client";
import { useParams } from "react-router-dom";
import '../App.css';

// Create a socket instance
let socket;

// PrivateChat component definition
const PrivateChat = ({ user }) => {
  // State for storing messages and the input value for sending messages
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState("");

  // Extract the chatId parameter from the URL
  const { chatId: encodedChatId } = useParams();
  const chatId = decodeURIComponent(encodedChatId);

  // Create refs for the input and chat container elements
  const inputRef = useRef(null);
  const chatContainerRef = useRef(null);

  // Effect to scroll to the bottom of the chat container when new messages are received
  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [messages]);

  // Effect to initialize the socket connection and fetch existing messages
  useEffect(() => {
    // Initialize socket connection
    socket = io("http://localhost:5000");

    // Handle socket connection and login event
    socket.on("connect", () => {
      console.log(`Socket connected with ID: ${socket.id}`);
      socket.emit("login", user.id);
    });

    // Function to fetch existing private messages for the chat
    const fetchMessages = async () => {
      try {
        console.log(`Fetching messages for chatId: ${chatId}`);
        const receiverUsername = chatId.split("-").find((username) => username !== user.username);
        const messageChatId = [user.username, receiverUsername].sort().join("-");

        // Fetch messages from the server
        const res = await axios.get(
          `http://localhost:5000/api/chat/privateMessages/${messageChatId}`,
          { withCredentials: true }
        );

        // Add the isUserSender property to each message and reverse the order for displaying
        setMessages(
          res.data.messages
            .map((message) => {
              return {
                ...message,
                isUserSender: message.sender === user.username,
              };
            })
            .reverse()
        );
      } catch (err) {
        console.error(err);
      }
    };

    // Fetch existing messages for the chat
    fetchMessages();

    // Listen for new private messages from the server
    socket.on("privateMessage", (message) => {
      console.log(`Received privateMessage event: ${JSON.stringify(message)}`);
      if (message.chatId === chatId) {
        setMessages((prevMessages) => {
          return [
            ...prevMessages,
            {
              ...message,
              isUserSender: message.sender === user.username,
              status: "delivered",
            },
          ];
        });
        
        // Scroll to the bottom after receiving a new message
        chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
      }
    });

    // Cleanup function to remove socket listeners and close the socket connection
    return () => {
      socket.off("privateMessage");
      socket.off("updateMessageStatus");
      socket.emit("logout", user.id);
      socket.close();
    };
  }, [chatId, user]);

  // Function to send a private message
  const sendMessage = async (e) => {
    e.preventDefault();

    // Get the receiver's username and create the chatId for the message
    const receiverUsername = chatId.split("-").find((username) => username !== user.username);
    const messageChatId = [user.username, receiverUsername].sort().join("-");

    // Create the message object
    const message = {
      text: inputValue,
      chatId: messageChatId,
      sender: user.username,
      receiver: receiverUsername,
      timestamp: Date.now(),
      isUserSender: true,
      status: "sent",
    };

    // Emit the "sendPrivateMessage" event with the message data
    socket.emit("sendPrivateMessage", message);

    // Clear the input field after sending the message
    setInputValue("");
  };

  // Function to handle changes in the input field
  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };

  // JSX to render the PrivateChat component
  return (
    <div className="chat">
      <div className="chat-header clearfix">
        <img src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/195612/chat_avatar_01_green.jpg" alt="avatar" />
  
        <div className="chat-about">
          <div className="chat-with">Chat with {chatId.split("-").find((username) => username !== user.username)}</div>
          <div className="chat-num-messages">already {messages.length} messages</div>
        </div>
        <i className="fa fa-star"></i>
      </div>
  
      <div className="chat-history" ref={chatContainerRef}>
        <ul>
          {messages.map((message, index) => (
            <li className="clearfix" key={index}>
              <div className={`message-data ${message.isUserSender ? 'align-right' : 'align-left'}`}>
                <span className="message-data-name">{message.isUserSender ? "You" : message.sender}</span>
                <span className="message-data-status">
                  Status: {message.status || 'sent'}
                </span>
                <i className={`fa fa-circle ${message.isUserSender ? 'me' : ''}`}></i>
              </div>
              <div className={`message ${message.isUserSender ? 'my' : 'other'}-message float-right`}>
                {message.text}
              </div>
            </li>
          ))}
        </ul>
      </div>
  
      <div className="chat-message clearfix">
        <form onSubmit={sendMessage}>
          <textarea
            name="message-to-send"
            id="message-to-send"
            placeholder="Type your message"
            rows="3"
            value={inputValue}
            onChange={handleInputChange}
            onKeyPress={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage(e);
              }
            }}
          ></textarea>

          <i className="fa fa-file-o"></i> &nbsp;&nbsp;&nbsp;
          <i className="fa fa-file-image-o"></i>
          <button type="submit">Send</button>
        </form>
      </div>
    </div>
  );
};

export default PrivateChat;


==============================

-ProtectedChatRoom.js
// ProtectedChatRoom.js
import React from 'react';
import { Navigate, useParams } from 'react-router-dom';  // Import the required modules
import UseAuth from '../hooks/UseAuth';  // Import the custom hook
import ChatRoom from './ChatRoom';  // Import the ChatRoom component

const ProtectedChatRoom = () => {
  const { user } = UseAuth();  // Get the user from the Auth context using the custom hook
  const { roomId } = useParams();  // Get the roomId from URL parameters using React Router's useParams hook

  // If there is no user logged in, redirect to the login page
  if (!user) {
    return <Navigate to="/login" />;
  }

  // If a user is logged in, render the ChatRoom component passing user and roomId as props
  return <ChatRoom user={user} roomId={roomId} />;
};

export default ProtectedChatRoom;


==============================

-ProtectedRoute.js
// Import necessary libraries and modules
import React from 'react';
import { Route, useNavigate } from 'react-router-dom';
import UseAuth from '../hooks/UseAuth';

// Define the ProtectedRoute component
const ProtectedRoute = ({ component: Component, ...rest }) => {
  // Get the authenticated user from the UseAuth hook
  const { user } = UseAuth();
  // Get the navigate function from react-router-dom
  const navigate = useNavigate();

  // Render the Route with custom element based on user authentication
  return (
    <Route
      {...rest}
      element={
        // If the user is authenticated, render the component
        user ? <Component /> : (
          // If the user is not authenticated, navigate to '/login' and render nothing (null)
          navigate('/login'), null
        )
      }
    />
  );
};

export default ProtectedRoute;


==============================

-RegisterForm.js
// Importing necessary libraries
import React, { useState } from 'react';
import axios from 'axios';

// Defining the RegisterForm component
function RegisterForm() {
  // State variables for username and password
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  // Function to handle form submission
  const handleSubmit = async (event) => {
    event.preventDefault(); // Prevent the default form submission behavior

    try {
      // Sending a POST request to the server to register the user
      await axios.post('http://localhost:5000/api/users/register', { username, password }, {
        withCredentials: true // Include credentials (like cookies) with the request
      });
      alert('Registered successfully'); // Show an alert when registration is successful
    } catch (error) {
      // If there's an error, log the error response data to the console
      console.error('Failed to register', error.response.data);
    }
  };

  return (
    // Form for user registration, with event handler for form submission
    <form onSubmit={handleSubmit}>
      <label>
        Username:
        <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} />
      </label>
      <label>
        Password:
        <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
      </label>
      <button type="submit">Register</button> {/* Submit button for form submission */}
    </form>
  );
}

export default RegisterForm; // Exporting the RegisterForm component for use in other files


==============================

-RoomList.js
// RoomList.js
import React, { useContext, useEffect, useState } from "react";
import axios from "axios";
import { useNavigate } from "react-router-dom";
import UseAuth from "../hooks/UseAuth";
import { Link } from "react-router-dom";
import { RoomsContext } from "../contexts/RoomsContext";
import { ReactComponent as DeleteIcon } from "./media/delete.svg";
import { ReactComponent as LeaveIcon } from "./media/leave.svg";
import { ReactComponent as CorrectIcon } from "./media/correct.svg";
import ChatRoom from "./ChatRoom";

const RoomList = () => {
  // Get the rooms data from the RoomsContext
  const { rooms, setRooms } = useContext(RoomsContext);

  // Initialize hooks and states
  const navigate = useNavigate();
  const { user } = UseAuth();
  const [selectedRoomMembers, setSelectedRoomMembers] = useState([]);
  const [selectedRoomId, setSelectedRoomId] = useState(null);
  const [chatRoomMembers, setChatRoomMembers] = useState([]);
  const [onlineUsers, setOnlineUsers] = useState({});
  const [members, setMembers] = useState([]);

  // Fetch the list of rooms from the server on component mount
  useEffect(() => {
    if (!user) {
      navigate("/login"); // Redirect to login page if user is not logged in
    } else {
      const fetchRooms = async () => {
        try {
          const res = await axios.get("http://localhost:5000/api/rooms", {
            withCredentials: true, // Send credentials along with the request
          });
          setRooms(res.data.rooms); // Update the state with fetched rooms data
        } catch (err) {
          console.error(err);
        }
      };

      fetchRooms();
    }
  }, [user, navigate]);

  // Function to delete a room by its ID
  const deleteRoom = async (roomId) => {
    try {
      await axios.delete(`http://localhost:5000/api/rooms/${roomId}`, {
        withCredentials: true, // Send credentials along with the request
      });
      const res = await axios.get("http://localhost:5000/api/rooms", {
        withCredentials: true, // Send credentials along with the request
      });
      setRooms(res.data.rooms); // Update the state with updated rooms data after deletion
    } catch (err) {
      console.error(err);
    }
  };

  // Function to join a room by its ID
  const joinRoom = async (roomId) => {
    try {
      await axios.post(
        `http://localhost:5000/api/rooms/join/${roomId}`,
        {},
        { withCredentials: true } // Send credentials along with the request
      );
      // Update the rooms state by adding the current user to the joined room's members list
      setRooms((prevRooms) => {
        return prevRooms.map((room) => {
          if (room.id === roomId) {
            return {
              ...room,
              members: [...room.members, user.username],
            };
          } else {
            return room;
          }
        });
      });
    } catch (err) {
      console.error(err);
    }
  };

  // Function to leave a room by its ID
  const leaveRoom = async (roomId) => {
    try {
      await axios.post(
        `http://localhost:5000/api/rooms/leave/${roomId}`,
        {},
        { withCredentials: true } // Send credentials along with the request
      );
      // Update the rooms state by removing the current user from the left room's members list
      setRooms((prevRooms) => {
        return prevRooms.map((room) => {
          if (room.id === roomId) {
            return {
              ...room,
              members: room.members.filter((member) => member !== user.username),
            };
          } else {
            return room;
          }
        });
      });
    } catch (err) {
      console.error(err);
    }
  };

  // Function to handle click on a room, set the selected room's members and ID
  const handleRoomClick = (members, roomId) => {
    setSelectedRoomMembers(members);
    setSelectedRoomId(roomId);
  };

  return (
    <div className="room-user-list-container">
      <div className="room-list">
        <h2>Chat Rooms</h2>
        {rooms.map((room) => (
          <div key={room.id}>
            <h3
              className="room-name"
              onClick={() => handleRoomClick(room.members, room.id)}
            >
              {room.name}
            </h3>
            <div className="room-buttons">
              {room.members.includes(user.username) ? (
                <button disabled>
                  <CorrectIcon />
                  Joined
                </button>
              ) : (
                <button onClick={() => joinRoom(room.id)}>Join</button>
              )}
              <button onClick={() => leaveRoom(room.id)}>
                <LeaveIcon />
              </button>
              <button onClick={() => deleteRoom(room.id)}>
                <DeleteIcon />
              </button>
            </div>
          </div>
        ))}
      </div>
      {selectedRoomId && selectedRoomMembers.includes(user.username) ? (
        <ChatRoom
          user={user}
          roomId={selectedRoomId}
          roomName={rooms.find((room) => room.id === selectedRoomId).name}
          chatRoomMembers={chatRoomMembers}
          setChatRoomMembers={setChatRoomMembers}
          setOnlineUsers={setOnlineUsers}
          setMembers={setMembers}
        />
      ) : (
        <div>You are not a member, please join the room!</div>
      )}
      <div className="user-list">
        {members.map((member, index) =>
          member !== user.username ? (
            <div key={index}>
              <Link to={`/private/${[user.username, member].sort().join("-")}`}>
                {member}
              </Link>
              {onlineUsers[member] ? (
                <span style={{ color: "green" }}>â—‰</span>
              ) : (
                <span style={{ color: "red" }}>â—‰</span>
              )}
            </div>
          ) : null
        )}
      </div>
    </div>
  );
};

export default RoomList;


==============================

-AuthContext.js
// AuthContext.js
import React, { createContext, useState, useEffect } from 'react';
import io from 'socket.io-client';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  // State to store user information
  const [user, setUser] = useState(null);
  
  // State to store the socket connection
  const [socket, setSocket] = useState(null);

  // Function to create a socket connection when the user logs in
  const login = (username) => {
    setUser({ username });

    // Establish a new socket connection to the server
    const newSocket = io('http://localhost:5000');

    // Emit a 'login' event to the server with the username
    newSocket.emit('login', username);

    // Save the new socket connection in the state
    setSocket(newSocket);
  };

  // Function to disconnect the socket and clear the user information when the user logs out
  const logout = () => {
    setUser(null);

    if (socket) {
      // Emit a 'logout' event to the server with the current username
      socket.emit('logout', user.username);

      // Disconnect the socket
      socket.disconnect();
    }

    // Clear the socket from the state
    setSocket(null);
  };

  // Cleanup the socket connection on component unmount
  useEffect(() => {
    return () => {
      if (socket) {
        // Disconnect the socket if it exists when the component is unmounted
        socket.disconnect();
      }
    };
  }, [socket]);

  // Provide the user, login, and logout functions to the children components
  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};


==============================

-ChatContext.js
// Importing necessary hooks and context from React
import { useContext } from 'react';
import { ChatContext } from '../contexts/ChatContext';

// This is a custom hook that wraps the useContext hook from React.
// It provides access to the ChatContext which contains chat messages.
const useChat = () => {
  // useContext is a hook that returns the context value.
  // In this case, the context value is an object that contains the "messages" state and its updater function "setMessages".
  return useContext(ChatContext);
};

export default useChat;

// Importing necessary hooks and context from React
import React, { createContext, useState } from 'react';

// Creating a Context object. When React renders a component that subscribes to this Context object,
// it will read the current context value from the closest matching Provider above it in the tree.
export const ChatContext = createContext();

// The ChatProvider component wraps its children with a context provider that allows them to access the "messages" state.
// Any child component can read or update the "messages" state if it's wrapped with this Provider.
export const ChatProvider = ({ children }) => {
  // "messages" state is initialized as an empty array. It's meant to hold chat messages.
  // setMessages is the updater function for the "messages" state.
  const [messages, setMessages] = useState([]);

  // The Provider component allows child components to subscribe to context changes.
  return (
    <ChatContext.Provider value={{ messages, setMessages }}>
      {/* children represents the inner content of this component. In other words, any elements/components between the opening and closing tags of this component. */}
      {children}
    </ChatContext.Provider>
  );
};


==============================

-RoomsContext.js
// Importing necessary libraries and hooks from React
import { createContext, useState } from 'react';

// Create a context for Rooms
// This context will be used to share rooms state across different components
export const RoomsContext = createContext();

// Create a context provider component
// This component will wrap other components and provide them access to the rooms state
export const RoomsProvider = ({ children }) => {

  // Define a state variable for rooms with its setter function
  // Initial value of rooms is an empty array
  const [rooms, setRooms] = useState([]);

  // The provider component returns a RoomsContext.Provider component
  // The value prop of the provider is an object with the rooms state and its setter function
  // This makes the rooms state and the function to update it available to all child components
  // The children prop is used to render the child components that this provider will wrap
  return (
    <RoomsContext.Provider value={{ rooms, setRooms }}>
      {children}
    </RoomsContext.Provider>
  );
};


==============================

-UseAuth.js
// Importing the necessary libraries and modules
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

// UseAuth is a custom hook that enables any component in our application 
// to access the authentication context. This is useful for determining 
// if a user is authenticated, obtaining the current user's information, etc.
const UseAuth = () => {
  // useContext is a React hook that allows you to access context data. 
  // Here we are using it to access the data in AuthContext.
  return useContext(AuthContext);
};

// Exporting the UseAuth hook so it can be used in other parts of the application.
export default UseAuth;


==============================

-UseChat.js
// Importing the necessary dependencies
import { useContext } from "react"; // React's useContext hook is used for accessing the context
import { ChatContext } from "../contexts/ChatContext"; // Importing ChatContext to use it in our custom hook

// A custom hook called useChat that uses the useContext hook to access the ChatContext
const useChat = () => {
  return useContext(ChatContext); // Using useContext to access the ChatContext and returning it
};

export default useChat; // Exporting the useChat custom hook for use in other components


==============================

-index.js
import React from 'react';
import ReactDOM from "react-dom/client";
import { BrowserRouter as Router } from 'react-router-dom';
import App from './App';
import { AuthProvider } from './contexts/AuthContext';
import reportWebVitals from "./reportWebVitals";


const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <AuthProvider>
      <Router>
        <App />
      </Router>
    </AuthProvider>
    </React.StrictMode>
);

reportWebVitals();


==============================

-reportWebVitals.js
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


==============================

-setupTests.js
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

